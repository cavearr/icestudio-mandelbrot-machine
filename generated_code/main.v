// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main #(
 parameter v736259 = 25000000,
 parameter v635beb = 400000,
 parameter v998150 = 0,
 parameter v8cc579 = 66,
 parameter v73d0f0 = 500,
 parameter v3bec5a = 5,
 parameter v2e7aef = 1,
 parameter v868116 = 1,
 parameter vf9f4f9 = 4,
 parameter v853baa = 192,
 parameter va39b27 = 100,
 parameter ve8ac7d = 64,
 parameter v4dcdd3 = 192,
 parameter v24d0a4 = 60,
 parameter vbc9f84 = 100
) (
 input vbacd3a,
 input v10c9e7,
 input v36f371,
 input v11a4a0,
 output [1:0] v02d781,
 output [1:0] v3ef8ce,
 output [1:0] ved8336,
 output [1:0] v1e5cd8,
 output [0:7] vinit,
 inout v158ce4,
 inout v198889
);
 localparam p0 = v868116;
 localparam p1 = v3bec5a;
 localparam p2 = v8cc579;
 localparam p3 = v998150;
 localparam p7 = v4dcdd3;
 localparam p8 = vbc9f84;
 localparam p9 = ve8ac7d;
 localparam p10 = v24d0a4;
 localparam p22 = v736259;
 localparam p23 = v635beb;
 localparam p24 = vf9f4f9;
 localparam p25 = v853baa;
 localparam p26 = va39b27;
 localparam p28 = v73d0f0;
 localparam p30 = v2e7aef;
 wire w4;
 wire [0:15] w5;
 wire [0:15] w6;
 wire [0:15] w11;
 wire [0:15] w12;
 wire [0:15] w13;
 wire w14;
 wire [0:15] w15;
 wire [0:15] w16;
 wire [0:1] w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:11] w27;
 wire w29;
 wire [0:9] w31;
 wire [0:9] w32;
 wire w33;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire w43;
 wire w44;
 wire [0:11] w45;
 wire w46;
 wire w47;
 wire w48;
 wire w49;
 wire w50;
 wire w51;
 wire w52;
 wire w53;
 wire w54;
 wire w55;
 wire w56;
 wire w57;
 wire w58;
 wire w59;
 wire w60;
 wire [0:11] w61;
 wire [0:11] w62;
 wire w63;
 wire w64;
 wire w65;
 wire [0:1] w66;
 wire w67;
 wire w68;
 wire w69;
 wire w70;
 wire w71;
 wire w72;
 wire [0:9] w73;
 wire [0:1] w74;
 wire w75;
 wire [0:9] w76;
 wire [0:1] w77;
 wire w78;
 wire w79;
 wire [0:9] w80;
 wire [0:9] w81;
 wire [0:9] w82;
 wire w83;
 wire [0:9] w84;
 wire [0:9] w85;
 wire [0:9] w86;
 wire w87;
 wire w88;
 wire w89;
 wire w90;
 wire w91;
 wire w92;
 wire w93;
 wire w94;
 wire w95;
 assign w4 = vbacd3a;
 assign v02d781 = w17;
 assign v198889 = w19;
 assign v158ce4 = w20;
 assign w21 = v11a4a0;
 assign w33 = v36f371;
 assign w34 = v36f371;
 assign w35 = v36f371;
 assign w37 = v10c9e7;
 assign v3ef8ce = w66;
 assign ved8336 = w74;
 assign v1e5cd8 = w77;
 assign w11 = w5;
 assign w12 = w6;
 assign w34 = w33;
 assign w35 = w33;
 assign w35 = w34;
 assign w40 = w38;
 assign w42 = w38;
 assign w42 = w40;
 assign w44 = w43;
 assign w47 = w46;
 assign w48 = w46;
 assign w48 = w47;
 assign w49 = w46;
 assign w49 = w47;
 assign w49 = w48;
 assign w50 = w46;
 assign w50 = w47;
 assign w50 = w48;
 assign w50 = w49;
 assign w51 = w46;
 assign w51 = w47;
 assign w51 = w48;
 assign w51 = w49;
 assign w51 = w50;
 assign w52 = w46;
 assign w52 = w47;
 assign w52 = w48;
 assign w52 = w49;
 assign w52 = w50;
 assign w52 = w51;
 assign w53 = w46;
 assign w53 = w47;
 assign w53 = w48;
 assign w53 = w49;
 assign w53 = w50;
 assign w53 = w51;
 assign w53 = w52;
 assign w54 = w46;
 assign w54 = w47;
 assign w54 = w48;
 assign w54 = w49;
 assign w54 = w50;
 assign w54 = w51;
 assign w54 = w52;
 assign w54 = w53;
 assign w55 = w46;
 assign w55 = w47;
 assign w55 = w48;
 assign w55 = w49;
 assign w55 = w50;
 assign w55 = w51;
 assign w55 = w52;
 assign w55 = w53;
 assign w55 = w54;
 assign w57 = w56;
 assign w58 = w56;
 assign w58 = w57;
 assign w59 = w56;
 assign w59 = w57;
 assign w59 = w58;
 assign w60 = w56;
 assign w60 = w57;
 assign w60 = w58;
 assign w60 = w59;
 assign w64 = w63;
 assign w68 = w67;
 assign w69 = w67;
 assign w69 = w68;
 assign w81 = w80;
 assign w82 = w80;
 assign w82 = w81;
 assign w85 = w84;
 assign w86 = w84;
 assign w86 = w85;
 assign w89 = w88;
 assign w91 = w90;
 ve2b7eb #(
  .vd29ea2(p0),
  .v204bed(p1),
  .vecb3d5(p2),
  .ve58c06(p3)
 ) vba26bf (
  .v328508(w4),
  .vdbfa46(w46)
 );
 main_vd18f21 vd18f21 (
 
 );
 main_vb5f312 #(
  .REDUCED_W(p9),
  .REDUCED_H(p10)
 ) vb5f312 (
  .addr(w5),
  .din(w6),
  ._dout(w15),
  .clk(w51),
  .start_x(w81),
  .start_y(w85),
  .we_n(w88),
  .oe_n(w90)
 );
 main_ve9b716 #(
  .WINDOW_WIDTH(p7),
  .WINDOW_HEIGHT(p8)
 ) ve9b716 (
  .addr(w11),
  .din(w12),
  ._dout(w13),
  .in_window(w14),
  .clk(w52),
  .start_x(w82),
  .start_y(w86),
  .we_n(w89),
  .oe_n(w91)
 );
 main_v9a16d4 v9a16d4 (
  .A(w13),
  .in_window(w14),
  .B(w15),
  .C(w16)
 );
 v80ac84 v0624f4 (
  .v67a3fc(w17),
  .v03aaf0(w64),
  .vee8a83(w68)
 );
 main_v8deb2d v8deb2d (
  .pixel(w61),
  .R(w66),
  .G(w74),
  .B(w77)
 );
 vfebcfe vf65ef5 (
  .v9fb85f(w18)
 );
 vea7a9f #(
  .vaa7e21(p22),
  .vf72171(p23)
 ) v2ed790 (
  .vc79dbf(w19),
  .v809f00(w20),
  .v8d5a0a(w21),
  .v4a0eb9(w27),
  .v31e23c(w45),
  .v195602(w55),
  .v15d637(w59)
 );
 main_v375c16 v375c16 (
  .clk(w46),
  .reset(w56),
  .button_up(w65),
  .button_down(w70),
  .gin(w71),
  .button_left(w72),
  .button_right(w75),
  .button_a(w78),
  .button_b(w79),
  .glat(w83),
  .gclk(w87)
 );
 main_vfc2db4 #(
  .BPP(p24),
  .B_W(p25),
  .B_H(p26)
 ) vfc2db4 (
  .bypass(w18),
  .clk(w47),
  .pixel_smoothed(w61),
  .pixRGB(w62),
  .hsync_in(w63),
  .vsync_in(w67),
  .hc(w73),
  .vc(w76),
  .bx(w80),
  .by(w84)
 );
 v0a6cbe #(
  .v32686c(p28)
 ) v8f119d (
  .va9e867(w29),
  .v809991(w48)
 );
 va20433 #(
  .v71e305(p30)
 ) v807997 (
  .vf54559(w29),
  .va4102a(w49),
  .ve8318d(w56)
 );
 main_v6fa439 v6fa439 (
  .joy_x(w31),
  .joy_y(w32),
  .clk(w53),
  .rst(w58),
  .win_x(w80),
  .win_y(w84)
 );
 v370abb v184ef1 (
  .vb192d0(w34),
  .vd53c9c(w36),
  .v030ad0(w78),
  .v27dec4(w93)
 );
 v370abb vc2335d (
  .vb192d0(w33),
  .vd53c9c(w39),
  .v030ad0(w79),
  .v27dec4(w92)
 );
 vba518e v16ec4e (
  .v0e28cb(w43),
  .vcbab45(w72),
  .v3ca442(w94)
 );
 v3676a0 v40adeb (
  .v0e28cb(w35),
  .vcbab45(w41)
 );
 vba518e v8b4bcb (
  .v0e28cb(w44),
  .vcbab45(w75),
  .v3ca442(w95)
 );
 vba518e v579cc7 (
  .v0e28cb(w38),
  .v3ca442(w39),
  .vcbab45(w70)
 );
 vba518e v0a34fd (
  .v3ca442(w36),
  .v0e28cb(w40),
  .vcbab45(w65)
 );
 v3676a0 vdcd89c (
  .v0e28cb(w37),
  .vcbab45(w38)
 );
 vba518e v01fd03 (
  .v3ca442(w41),
  .v0e28cb(w42),
  .vcbab45(w43)
 );
 main_vaf7d43 vaf7d43 (
  .adc_y(w27),
  .x_out(w31),
  .y_out(w32),
  .adc_x(w45),
  .clk(w54),
  .reset(w60),
  .vsync_in(w69),
  .down(w92),
  .up(w93),
  .left(w94),
  .right(w95)
 );
 main_vaba014 vaba014 (
  .xa(w5),
  .xdo(w6),
  .xdi(w16),
  .clk(w50),
  .rst(w57),
  .pixRGB444(w62),
  ._hsync(w63),
  ._vsync(w67),
  .gin(w71),
  .hc(w73),
  .vc(w76),
  .glat(w83),
  .gclk(w87),
  .xwe(w88),
  .xoe(w90)
 );
 assign vinit = 8'b00000000;
endmodule

//---------------------------------------------------
//-- Text Terminal for VGA
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Aparently simple, but complex design to discuss about PLL and global variables in Icestudio
//---------------------------------------------------
//---- Top entity
module ve2b7eb #(
 parameter ve58c06 = 0,
 parameter vecb3d5 = 66,
 parameter v204bed = 5,
 parameter vd29ea2 = 1,
 parameter v16d365 = "SIMPLE"
) (
 input v328508,
 output vdbfa46,
 output v3ead5b,
 output v333bf4
);
 localparam p0 = ve58c06;
 localparam p1 = vecb3d5;
 localparam p2 = v204bed;
 localparam p3 = vd29ea2;
 localparam p4 = v16d365;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 assign vdbfa46 = w7;
 assign v3ead5b = w8;
 assign v333bf4 = w9;
 assign w10 = v328508;
 vc83dcd va0dc84 (
  .v608bd9(w5)
 );
 vc4dd08 vda5929 (
  .v608bd9(w6)
 );
 ve2b7eb_vd4bd9d #(
  .DIVR(p0),
  .DIVF(p1),
  .DIVQ(p2),
  .FILTER_RANGE(p3),
  .FEEDBACK_PATH(p4)
 ) vd4bd9d (
  .RESETB(w5),
  .BYPASS(w6),
  .PLLOUTGLOBAL(w7),
  .PLLOUTCORE(w8),
  .LOCK(w9),
  .PACKAGEPIN(w10)
 );
endmodule

//---------------------------------------------------
//-- PLL40_PAD
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- SB_PLL40_PAD
//---------------------------------------------------

module ve2b7eb_vd4bd9d #(
 parameter DIVR = 0,
 parameter DIVF = 0,
 parameter DIVQ = 0,
 parameter FILTER_RANGE = 0,
 parameter FEEDBACK_PATH = 0
) (
 input PACKAGEPIN,
 input RESETB,
 input BYPASS,
 output PLLOUTGLOBAL,
 output PLLOUTCORE,
 output LOCK
);
 SB_PLL40_PAD #(
 		.FEEDBACK_PATH("SIMPLE"),
 		.DIVR(DIVR),		// DIVR =  0
 		.DIVF(DIVF),	// DIVF = 79
 		.DIVQ(DIVQ),		// DIVQ =  4
 		.FILTER_RANGE(FILTER_RANGE)	// FILTER_RANGE = 1
 	) uut (
 		.LOCK(LOCK),
 		.RESETB(RESETB),
 		.BYPASS(BYPASS),
 		.PACKAGEPIN(PACKAGEPIN),
 		.PLLOUTCORE(PLLOUTCORE),
 		.PLLOUTGLOBAL(PLLOUTGLOBAL)
 		);
endmodule
//---- Top entity
module vc83dcd (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc83dcd_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 1 to the output wire
//---------------------------------------------------

module vc83dcd_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule
//---- Top entity
module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 0 to the output wire
//---------------------------------------------------

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule
//---- Top entity
module v80ac84 (
 input vee8a83,
 input v03aaf0,
 output [1:0] v67a3fc
);
 wire w0;
 wire w1;
 wire [0:1] w2;
 assign w0 = vee8a83;
 assign w1 = v03aaf0;
 assign v67a3fc = w2;
 v80ac84_v9a2a06 v9a2a06 (
  .i1(w0),
  .i0(w1),
  .o(w2)
 );
endmodule

//---------------------------------------------------
//-- Bus2-Join-all
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Bus2-Join-all: Joint two wires into a 2-bits Bus
//---------------------------------------------------

module v80ac84_v9a2a06 (
 input i1,
 input i0,
 output [1:0] o
);
 assign o = {i1, i0};
 
endmodule
//---- Top entity
module vfebcfe (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vfebcfe_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- bit-1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Constant bit 1
//---------------------------------------------------

module vfebcfe_vb2eccd (
 output q
);
 //-- Constant bit-1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module vea7a9f #(
 parameter vaa7e21 = 12000000,
 parameter vf72171 = 400000
) (
 input v195602,
 input v15d637,
 input v8d5a0a,
 output [11:0] v33c8d6,
 output [11:0] v75d11d,
 output [11:0] v4a0eb9,
 output [11:0] v31e23c,
 output v3351ca,
 inout v809f00,
 inout vc79dbf
);
 localparam p0 = vf72171;
 localparam p1 = vaa7e21;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:11] w8;
 wire [0:11] w9;
 wire [0:11] w10;
 wire [0:11] w11;
 assign w2 = v15d637;
 assign w3 = v8d5a0a;
 assign w4 = v195602;
 assign v809f00 = w5;
 assign vc79dbf = w6;
 assign v3351ca = w7;
 assign v31e23c = w8;
 assign v4a0eb9 = w9;
 assign v75d11d = w10;
 assign v33c8d6 = w11;
 vea7a9f_ve9ee3c #(
  .FSCL(p0),
  .FCLK(p1)
 ) ve9ee3c (
  .reset(w2),
  .int(w3),
  .clk(w4),
  .sda(w5),
  .scl(w6),
  .sampletick(w7),
  .ana0(w8),
  .ana1(w9),
  .ana2(w10),
  .ana3(w11)
 );
endmodule

//---------------------------------------------------
//-- ADC_ADS7924_Arias
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- This module is a block that reads the 4 ADC inputs of the ADS7924 and presents the results as plain four 12-bit values.
//---------------------------------------------------

module vea7a9f_ve9ee3c #(
 parameter FCLK = 0,
 parameter FSCL = 0
) (
 input clk,
 input reset,
 input int,
 output [11:0] ana3,
 output [11:0] ana2,
 output [11:0] ana1,
 output [11:0] ana0,
 output sampletick,
 inout sda,
 inout scl
);
 ////////////////////////////////////////////////////////////////////
 //                ADS7924 reader (via I2C bus)
 // J. Arias (2024) Public domain sources
 //
 // This module is a block that reads the 4 ADC inputs of the ADS7924
 // and presents the results as plain four 12-bit values.
 // -First, it configure the ADC with "Auto-Burst Scan with Sleep" mode,
 //  with minimun sleep time (2.5ms / 4 = 625us), and 14us adquisition
 //  time (max source resistance: 100 kohm)
 // -Then it waits for BUSY pulses on the INT input, reads the 4 channel
 //  values, and keeps doing this again and again.
 // -A sample clock output is provided. This signal is low while the data
 //  is being updated. Output updates are atomic (the whole 12 bits of
 //  the outputs are written in parallel)
 //
 // I2C Details:
 // - ACK bits are ignored (there is nothing we can do if they fail, anyways)
 // - No clock stretching is allowed (this isn't a problem for the ADS7924)
 //
 // Performance:
 // - 1430 (+-20%) Samples/s. The sampling rate depends on an inaccurate 
 //   internal clock.
 // - 124 Logic cells.
 //
 // More info = https://groups.google.com/g/fpga-wars-explorando-el-lado-libre/c/9gcu-SFjloA
 
 // Clock dividers clk2 = 2*clkbit, almost square
 localparam DIVIDER = (FCLK/2)/FSCL;
 localparam NDIV = $clog2(DIVIDER);
 
 reg [NDIV-1:0]pres=0;
 always @(posedge clk) pres<= (pres==DIVIDER-1) ? 0 : pres+1;
 reg clk2=0;
 always @(posedge clk) clk2<=(pres<=(DIVIDER/2));
 
 reg clkbit=0;	// bit clock, active rising
 always @(posedge clk2) clkbit<=~clkbit;
 
 // SCL & SDA
 reg sclo1; // temp SCL output, 1/4 Tbit delay
 always @(negedge clk2) sclo1<=idle | (start&clkbit) | (stop&(~clkbit)) | clkbit;
 reg sclo;  // SCL output resampled (delayed 1 clk for equalization with respect SDA)
 always @(posedge clk) sclo<=sclo1;
 reg sdao;  // registered SDA output to avoid glitches
 always @(posedge clk) sdao <= idle | (start&clkbit) | (stop&(~clkbit)) | (datast&sh[8]) ;
 
 // Open-drain pins: SCL, SDA
 assign scl = sclo ? 1'bz : 1'b0;
 assign sda = sdao ? 1'bz : 1'b0;
 
 // bit counter (9 cycles: data + ACK)
 reg [3:0]bcnt=0;
 wire nxtinstr = (~datast)|bcnt[3];	// next instruction: after 9 cycles if in data state
 always @(posedge clkbit) bcnt<= nxtinstr ? 0 : bcnt+1;
 
 // Shift register (sda input and output)
 reg ssda;	// sampled SDA (SCL falling)
 always @(negedge scl) ssda<=sda;
 
 reg [8:0]sh; // 9-bit shift register
 always @(posedge clkbit) sh<= nxtinstr ? {ucode[7:0],ack} : {sh[7:0],ssda};
 
 /////////////////// SEQUENCER //////////////////////
 /// START / STOP / IDLE / DATA
 localparam IDL = 2'b00;
 localparam STA = 2'b01;
 localparam STP = 2'b10;
 localparam DAT = 2'b11;
 
 // instructions
 wire idle  = (ucode[10:9]==IDL);
 wire start = (ucode[10:9]==STA);
 wire stop  = (ucode[10:9]==STP);
 wire datast= (ucode[10:9]==DAT);
 
 localparam ACK = 1'b0;
 localparam NAK = 1'b1;
 wire ack =ucode[8];		// ACK bit to send
 
 wire goto=ucode[11];	// Goto to address 0
 wire wr0 =ucode[12];	// write channels #0 to #3
 wire wr1 =ucode[13];
 wire wr2 =ucode[14];
 wire wr3 =ucode[15];
 
 // address counter
 localparam ADDRST=16; 	// reset address
 reg [4:0]uaddr = ADDRST;// address counter
 
 always @(posedge clkbit or posedge reset)
 	if (reset) uaddr<=ADDRST;
 	// GOTO and IDLE with no data_av jumps to address 0
 	else uaddr<= (goto | (idle & (~data_av)))? 0 : uaddr + nxtinstr;
 	// GOTO jumps to address 0. IDLE blocks until data_av
 	//else uaddr<= goto ? 0 : uaddr + (nxtinstr & ((~idle)|data_av));
 
 // microcode ROM (asynchronous)
 //  includes control signals (write, goto) for current instruction, 
 //  and data to be loaded into the shift register for next instruction
 reg [15:0]ucode;	// not register, combinational
 always @*
 	case(uaddr)
 	// Operation loop
 	//              wr3-0  goto inst ack  data
 	5'd0 : ucode<={4'b0000,1'b0, IDL,1'bx,8'hxx};	// wait for INT edge
 	5'd1 : ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd2 : ucode<={4'b0000,1'b0, DAT, NAK,8'h82};	// reg #2, increment address
 	5'd3 : ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd4 : ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd5 : ucode<={4'b0000,1'b0, STA, NAK,8'h91};	// START, Slave address, read
 	5'd6 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	
 	5'd7 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA0_U
 	5'd8 : ucode<={4'b0001,1'b0, DAT, ACK,8'hFF};	// DATA0_L, write to AN0
 	5'd9 : ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA1_U
 	5'd10: ucode<={4'b0010,1'b0, DAT, ACK,8'hFF};	// DATA1_L, write to AN1
 	5'd11: ucode<={4'b0000,1'b0, DAT, ACK,8'hFF};	// DATA2_U
 	5'd12: ucode<={4'b0100,1'b0, DAT, ACK,8'hFF};	// DATA2_L, write to AN2
 	5'd13: ucode<={4'b0000,1'b0, DAT, NAK,8'hFF};	// DATA3_U
 	5'd14: ucode<={4'b1000,1'b0, DAT,1'bx,8'hXX};	// DATA3_L, write to AN3
 	5'd15: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 	
 	// Init: configuring ADC registers
 	5'd16: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd17: ucode<={4'b0000,1'b0, DAT, NAK,8'h80};	// reg #0, increment address
 	5'd18: ucode<={4'b0000,1'b0, DAT, NAK,8'hFC};	// Auto-Burst Scan with Sleep mode, ch #0
 	5'd19: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd20: ucode<={4'b0000,1'b0, STP,1'bx,8'hXX};	// STOP
 	
 	5'd21: ucode<={4'b0000,1'b0, STA, NAK,8'h90};	// START, Slave address, write
 	5'd22: ucode<={4'b0000,1'b0, DAT, NAK,8'h92};	// reg #0x12, increment address 
 	5'd23: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// INTCFG: INT=BUSY, active low
 	5'd24: ucode<={4'b0000,1'b0, DAT, NAK,8'h20};	// SLPCFG: Sleep: 2.5ms/4
 	5'd25: ucode<={4'b0000,1'b0, DAT, NAK,8'h04};	// ACQCFG: 4*2+6 = 14us
 	5'd26: ucode<={4'b0000,1'b0, DAT,1'bx,8'hXX};	// send last byte
 	5'd27: ucode<={4'b0000,1'b1, STP,1'bx,8'hXX};	// STOP, GOTO 0
 
 	default: ucode<=16'hxxxx;
 	endcase
 	
 // Output registers
 // notice the ACK bit hasn't been yet shifted in when 'nxtinstr' is asserted
 reg [7:0]olddat;	// previous byte
 always @(posedge clkbit) if (nxtinstr) olddat<=sh[7:0];
 reg [11:0]an0;
 reg [11:0]an1;
 reg [11:0]an2;
 reg [11:0]an3;
 always @(posedge clkbit) begin
 	if (nxtinstr & wr0) an0<={olddat,sh[7:4]};
 	if (nxtinstr & wr1) an1<={olddat,sh[7:4]};
 	if (nxtinstr & wr2) an2<={olddat,sh[7:4]};
 	if (nxtinstr & wr3) an3<={olddat,sh[7:4]};
 end
 
 // INT trigger
 // (Datasheet errata? There are 4 busy pulses, one per channel, when the datasheet
 // shows only one pulse on fig. 28 "Auto-Burst Scan With Sleep Operation Example".
 // Anyway, a workaround is implemented)
 reg [3:0]tim;	// Monostable timer (4 busy pulses -> single pulse)
 always @(posedge clkbit) tim <= int ? tim+(tim!=15) : 0;
 
 wire data_av =(tim==14); // Data Available for read
 
 // Sample Clock
 reg sampleck=0;
 always @(posedge clkbit) sampleck<= data_av ? 1'b0 :(goto ? 1'b1 : sampleck);
 
 assign sampletick = sampleck;
 assign ana0 = an0;
 assign ana1 = an1;
 assign ana2 = an2;
 assign ana3 = an3;
 
endmodule
//---- Top entity
module v0a6cbe #(
 parameter v32686c = 500
) (
 input v809991,
 output va9e867
);
 localparam p2 = v32686c;
 wire w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 assign w1 = v809991;
 assign va9e867 = w5;
 assign w6 = v809991;
 assign w7 = v809991;
 assign w6 = w1;
 assign w7 = w1;
 assign w7 = w6;
 v725b7e v6297a3 (
  .v9fb85f(w0)
 );
 vaf48eb ve24633 (
  .v7a9926(w0),
  .v17905c(w1),
  .v0e6b31(w3)
 );
 v8e2728 vf57b58 (
  .v10eedb(w3),
  .v2dffca(w4),
  .v0884a0(w6)
 );
 vd809c3 #(
  .v187a47(p2)
 ) v17f869 (
  .v6e1dd1(w4),
  .va9e2af(w5),
  .v5688a8(w7)
 );
endmodule

//---------------------------------------------------
//-- IniTic
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Emite un solo tic al iniciarse la FPGA.
//---------------------------------------------------
//---- Top entity
module v725b7e (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 v725b7e_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

//---------------------------------------------------
//-- 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Un bit constante a 1
//---------------------------------------------------

module v725b7e_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule
//---- Top entity
module vaf48eb (
 input v17905c,
 input v7a9926,
 output v0e6b31
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v17905c;
 assign w1 = v7a9926;
 assign v0e6b31 = w2;
 vaf48eb_v39aeaa v39aeaa (
  .Clock(w0),
  .D(w1),
  .Q(w2)
 );
endmodule

//---------------------------------------------------
//-- DFF ini = 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- DFF ini = 0
//---------------------------------------------------

module vaf48eb_v39aeaa (
 input Clock,
 input D,
 output Q
);
 reg _Q = 0;
 assign Q=_Q;
 always @(posedge Clock)
 begin
   _Q <= D;
 end
endmodule
//---- Top entity
module v8e2728 (
 input v0884a0,
 input v10eedb,
 output v2dffca
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v10eedb;
 assign v2dffca = w1;
 assign w2 = v0884a0;
 v8e2728_v115ffb v115ffb (
  .i(w0),
  .o(w1),
  .clk(w2)
 );
endmodule

//---------------------------------------------------
//-- Subida
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente
//---------------------------------------------------

module v8e2728_v115ffb (
 input clk,
 input i,
 output o
);
 reg q = 0;
 
 always @(posedge clk)
   q <= i;
   
 assign o = (~q & i);  
endmodule
//---- Top entity
module vd809c3 #(
 parameter v187a47 = 100
) (
 input v5688a8,
 input v6e1dd1,
 output veabfb2,
 output va9e2af
);
 localparam p4 = v187a47;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v6e1dd1;
 assign veabfb2 = w1;
 assign va9e2af = w2;
 assign w3 = v5688a8;
 vd809c3_v3140f5 #(
  .MS(p4)
 ) v3140f5 (
  .start(w0),
  .p(w1),
  .tic(w2),
  .clk(w3)
 );
endmodule

//---------------------------------------------------
//-- timer-msec CLONE
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar
//---------------------------------------------------

module vd809c3_v3140f5 #(
 parameter MS = 0
) (
 input clk,
 input start,
 output p,
 output tic
);
 //localparam MS;
 
 //-- Constante para dividir y obtener una señal de  
 //-- periodo 1ms
 localparam M = 25000;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el corazon
 wire rst_heart;
 
 //-- Overflow del temporizador del corazon
 wire ov_heart;
 
 //-- Habilitacion del corazon
 wire ena;
 
 //-- Tics del corazon
 wire tic_heart;
 
 //-- Contador del corazon
 reg [N-1:0] heart=0;
 
 always @(posedge clk)
   if (rst_heart)
     heart <= 0;
   else
     heart <= heart + 1;
 
 //-- Overflow del contador
 assign ov_heart = (heart == M-1);
 
 //-- La salida del corazon es la señal de overflow
 assign tic_heart = ov_heart;
 
 //-- Reset del corazon
 assign rst_heart =~ena | ov_heart;
 
 
 
 //--------------------------------------------
 //-- Contador de tics
 //--------------------------------------------
 
 //-- Calcular el numero de bits para almacenar MS tics
 localparam CB = $clog2(MS);
 
 reg [CB-1:0] counter = 0;
 
 //-- Overflow del contador
 wire ov;
 
 //-- Señal de reset del contador
 wire rst;
 
 always @(posedge clk)
 if (rst)
   counter <= 0;
 else
   if (tic_heart)
     counter <= counter + 1;
 
 //-- Evento: cuenta máxima de tics alcanzada
 assign ov = (counter == MS);
 
 //---------------------------------------
 //-- Biestable de estado del timer
 //-- 0: Apagado  
 //-- 1: Funcionando
 reg q = 0;
 
 always @(posedge clk)
   if (start)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
     
 //-- Lógica de reset
 //En función de la entrada, el estado y  
 // el overflow se inicializa el contador y 
 // se habilita el corazón de tics
 assign rst = ~q | ov | start;
 assign ena = ~rst;
 
 //-- Salida de pulso
 assign p = q;
 
 //-- Salida de tic
 //-- Saca un tic cuando ha finalizado la cuenta
 assign tic = ov;
 
endmodule
//---- Top entity
module va20433 #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p3 = v71e305;
 wire w0;
 wire w1;
 wire w2;
 assign w0 = va4102a;
 assign w1 = vf54559;
 assign ve8318d = w2;
 va20433_vb8adf8 #(
  .INI(p3)
 ) vb8adf8 (
  .clk(w0),
  .T(w1),
  .q(w2)
 );
endmodule

//---------------------------------------------------
//-- Biestable-T
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado
//---------------------------------------------------

module va20433_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input T,
 output q
);
 reg _q = INI;
 assign q=_q;
 always @(posedge clk)
   if (T)
     _q <= ~_q;
     
 
endmodule
//---- Top entity
module v370abb (
 input v27dec4,
 input vb192d0,
 output v030ad0,
 output vd53c9c
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign v030ad0 = w0;
 assign vd53c9c = w1;
 assign w3 = v27dec4;
 assign w4 = v27dec4;
 assign w5 = vb192d0;
 assign w6 = vb192d0;
 assign w4 = w3;
 assign w6 = w5;
 vba518e vb523bf (
  .vcbab45(w0),
  .v0e28cb(w3),
  .v3ca442(w6)
 );
 v3676a0 vde5c93 (
  .vcbab45(w2),
  .v0e28cb(w5)
 );
 vba518e vf65161 (
  .vcbab45(w1),
  .v3ca442(w2),
  .v0e28cb(w4)
 );
endmodule

//---------------------------------------------------
//-- DeMux-1-2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 1-to-2 DeMultplexer (1-bit channels)
//---------------------------------------------------
//---- Top entity
module vba518e (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 vba518e_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

//---------------------------------------------------
//-- AND2
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Two bits input And gate
//---------------------------------------------------

module vba518e_vf4938a (
 input a,
 input b,
 output c
);
 //-- AND gate
 //-- Verilog implementation
 
 assign c = a & b;
 
endmodule
//---- Top entity
module v3676a0 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v3676a0_vd54ca1 vd54ca1 (
  .a(w0),
  .q(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT gate (Verilog implementation)
//---------------------------------------------------

module v3676a0_vd54ca1 (
 input a,
 output q
);
 //-- NOT Gate
 assign q = ~a;
 
 
endmodule

module main_vd18f21
;
 // @include fix_mpy.v
 // @include fmul.v
 // @include fmul24.v
 // @include fmulbooth.v
 // @include videomodule.v
 // @include SYSTEM.v
 // @include sram_model.v
 // @include window_checker.v
 // @include resize_mapper.v
 // @include sram_resize.v
 // @include vga_smooth.v
 // @include rgb_444_to_222_lineal.v
 // @include nespad_module.v
 // @include joystick_controller.v
 // @include window_mapping.v
endmodule

module main_vb5f312 #(
 parameter REDUCED_W = 0,
 parameter REDUCED_H = 0
) (
 input clk,
 input we_n,
 input oe_n,
 input [15:0] addr,
 input [15:0] din,
 input [9:0] start_x,
 input [9:0] start_y,
 output [15:0] _dout
);
 wire data_valid;      
 
 
                  sram_resize#(.REDUCED_W(REDUCED_W),
                  .REDUCED_H(REDUCED_H)
                  )sram_inst (
         .clk(clk),
         .ce_n(1'b0),             // Always enabled
         .oe_n(oe_n),             // Output enable from SYSTEM
         .we_n(we_n),             // Write enable from SYSTEM
         .bhe_n(1'b0),            // Both bytes enabled
         .ble_n(1'b0),
         .addr({2'b00, addr}),     // Extend 16-bit xa to 18-bit addr
         .data_in(din),            // Data from SYSTEM to SRAM
         .data_out(_dout),         // Data from SRAM to SYSTEM
         .data_valid(data_valid),  // Data valid (not used by SYSTEM)
         .sx(start_x),
         .sy(start_y[8:0])
     );
endmodule

module main_ve9b716 #(
 parameter WINDOW_WIDTH = 0,
 parameter WINDOW_HEIGHT = 0
) (
 input clk,
 input we_n,
 input oe_n,
 input [15:0] addr,
 input [15:0] din,
 input [9:0] start_x,
 input [9:0] start_y,
 output in_window,
 output [15:0] _dout
);
 wire data_valid;      
 
  // SRAM model
     sram_model#(.WIN_W(WINDOW_WIDTH),
                  .WIN_H(WINDOW_HEIGHT)
                  )sram_inst (
         .clk(clk),
         .ce_n(1'b0),             // Always enabled
         .oe_n(oe_n),             // Output enable from SYSTEM
         .we_n(we_n),             // Write enable from SYSTEM
         .bhe_n(1'b0),            // Both bytes enabled
         .ble_n(1'b0),
         .addr({2'b00, addr}),     // Extend 16-bit xa to 18-bit addr
         .data_in(din),            // Data from SYSTEM to SRAM
         .data_out(_dout),         // Data from SRAM to SYSTEM
         .data_valid(data_valid),  // Data valid (not used by SYSTEM)
         .sx(start_x),
         .sy(start_y[8:0]),
         .in_window(in_window)
     );
   
endmodule

module main_v9a16d4 (
 input [15:0] B,
 input in_window,
 input [15:0] A,
 output [15:0] C
);
 assign C = (in_window) ? A : B;
 
endmodule

module main_v8deb2d (
 input [11:0] pixel,
 output [5:0] pixelConv,
 output [1:0] R,
 output [1:0] G,
 output [1:0] B
);
 rgb444_to_rgb222 rgb_converter (
     .pixel_in(pixel),  
     .pixel_out(pixelConv)  
 );
 
 assign R=pixelConv[5:4];
 assign G=pixelConv[3:2];
 assign B=pixelConv[1:0];
endmodule

module main_v375c16 (
 input clk,
 input reset,
 input [9:0] posX,
 input [9:0] posY,
 input button_up,
 input button_down,
 input button_left,
 input button_right,
 input button_a,
 input button_b,
 input glat,
 input gclk,
 output gin
);
 reg [7:0] stateb;
 
 always @(posedge clk) begin 
     stateb<={ button_a,
               button_b,
               1'b0,
               1'b0,
               button_up,
               button_down,
               button_left,
               button_right};
 end
 
 // NES pad simulator
 nespad_module nespad (
         .clk(clk),
         .reset(reset),
         .gclk(gclk),
         .glat(glat),
         .gin(gin),
         .buttons(stateb)
 );
endmodule

module main_vfc2db4 #(
 parameter BPP = 0,
 parameter B_W = 0,
 parameter B_H = 0
) (
 input clk,
 input [11:0] pixRGB,
 input hsync_in,
 input vsync_in,
 input [9:0] hc,
 input [9:0] vc,
 input bypass,
 input [9:0] bx,
 input [9:0] by,
 output [11:0] pixel_smoothed,
 output [1:0] Ro,
 output [1:0] Go,
 output [1:0] Bo,
 output hsync_out,
 output vsync_out
);
 vga_smooth #(
     .BITS_PER_PIXEL(BPP),
     .BWIDTH(B_W),
     .BHEIGHT(B_H)
 ) smooth_inst (
     .clk(clk),
     .pixel_in(pixRGB),
     .hc(hc),
     .vc(vc),
     .hsync_in(hsync_in),
     .vsync_in(vsync_in),
     .bypass(bypass), // 0 o 1
     .bx(bx),        // Por ejemplo, 100
     .by(by),        // Por ejemplo, 100
     .pixel_out(pixel_smoothed),
     .hsync_out(hsync_out),
     .vsync_out(vsync_out)
 );
 
endmodule

module main_v6fa439 (
 input clk,
 input rst,
 input [9:0] joy_x,
 input [9:0] joy_y,
 output [9:0] win_x,
 output [9:0] win_y
);
 window_mapping #(
 .POS_WIDTH(10),
       .POS_CENTER_X(10'd1000), 
       .POS_CENTER_Y(10'd1000), 
       .WIDTH(192),
       .HEIGHT(100),
       .MAX_W(640),
       .MAX_H(480)
 
   ) win_map (
       .clk  (clk),
       .rst  (rst),
       .pos_x(joy_x),   // 10 bits
       .pos_y(joy_y),   // 10 bits
       .winx (win_x),   // 10 bits
       .winy (win_y)    // 10 bits
   );
 
endmodule

module main_vaf7d43 (
 input clk,
 input [11:0] adc_y,
 input [11:0] adc_x,
 input vsync_in,
 input reset,
 output [9:0] x_out,
 output [9:0] y_out,
 output up,
 output down,
 output left,
 output right
);
 
 
 joystick_controller u_joystick (
     .clk    (clk),
     .mclk   (vsync_in),     // Por ejemplo, 1kHz de muestreo
     .rst  (reset),
     .x_adc  (adc_x),
     .y_adc  (adc_y),
     .x_out  (x_out),
     .y_out  (y_out),
     .up     (up),
     .down   (down),
     .left   (left),
     .right  (right)
 );
endmodule

module main_vaba014 (
 input clk,
 input rst,
 input [15:0] xdi,
 input gin,
 output [11:0] pixRGB444,
 output _vsync,
 output _hsync,
 output [9:0] vc,
 output [9:0] hc,
 output [15:0] xa,
 output [15:0] xdo,
 output xwe,
 output xoe,
 output gclk,
 output glat
);
 wire txd;
 wire mosi;
 wire sss;
 wire fss;
 wire sck;
 wire pinout;
 
 
 // Instantiate SYSTEM module
     SYSTEM sys_inst (
         .clk(clk),
         .reset(rst),             // Active high, matches top.v
         .hsyn(_hsync),
         .vsyn(_vsync),
         .hc(hc),
         .vc(vc),
         .video(pixRGB444),
         .xwe(xwe),
         .xoe(xoe),
         .xa(xa),
         .xdo(xdo),
         .xdi(xdi), 
         .pinin(0),
         .pinout(pinout),
         .rxd(0),
         .txd(txd),
         .sck(sck),
         .mosi(mosi),
         .miso(0),
         .fss(fss),
         .sss(sss),
         .gclk(gclk),
         .glat(glat),
         .gin(gin)
         // .deb0(), .deb1()      // Debug signals (not connected)
     );
 
endmodule
